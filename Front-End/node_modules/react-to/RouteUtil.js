'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _matchPath = require('./match/matchPath');

var _matchPath2 = _interopRequireDefault(_matchPath);

var _Util = require('./Util');

var _CacheOfTagControl = require('./CacheOfTagControl');

var _CacheOfTagControl2 = _interopRequireDefault(_CacheOfTagControl);

var _CacheOfLinkControl = require('./CacheOfLinkControl');

var _CacheOfLinkControl2 = _interopRequireDefault(_CacheOfLinkControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RouteUtil = function (_React$Component) {
  _inherits(RouteUtil, _React$Component);

  function RouteUtil() {
    var _Object$getPrototypeO;

    var _temp, _this, _ret;

    _classCallCheck(this, RouteUtil);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(RouteUtil)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.resetChildContext = function (match) {

      var routes = _this.context.routes || _this.initRoutes;
      if (routes.length > (typeof _this.context.parentRouteIndex === 'undefined' ? -1 : 0) + 1) routes.length = (typeof _this.context.parentRouteIndex === 'undefined' ? -1 : 0) + 1;

      if (match) {
        routes.push(_this);
      }
    }, _this.isCached = function () {
      if (_CacheOfTagControl2.default.isCached(_this)) {
        return 1;
      }
      if (_CacheOfLinkControl2.default.isCached(_this)) {
        return 2;
      }
      return 0;
    }, _this.checkCacheTag = function (remove) {
      var cache = void 0;
      if (remove) {
        cache = null;
      } else {
        cache = _this.props.cache;
        if (!cache) {
          cache = null;
        }
        if (cache === true) {
          cache = 'root';
        }
        if (cache !== 'parent' && cache !== 'root') {
          cache = null;
        }
      }
      _CacheOfTagControl2.default.put(_this, cache);
    }, _this.getParentPath = function () {
      var paths = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (_this.context.routes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var route = _step.value;

          if (route.matcher) paths.push(route.matcher.matchStr);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return paths.join('');
    }, _this.getSelfPath = function (matcher) {
      var paths = [_this.getParentPath()];
      if (matcher) paths.push(matcher.matchStr);
      return paths.join('');
    }, _this.checkPath = function (location) {
      var _this$props = _this.props;
      var pattern = _this$props.path;
      var index = _this$props.index;

      if (!pattern) {
        return { match: false };
      }
      pattern = (0, _Util.resetPath)(pattern);

      var _ref = location || {};

      var pathname = _ref.pathname;

      if (typeof pathname === 'undefined') {
        return { match: false };
      }
      pathname = (0, _Util.resetPath)(pathname);

      var parentPath = _this.getParentPath();

      var checkPathname = pathname;
      if (parentPath) {
        checkPathname = pathname.substring(parentPath.length);
      }

      var matcher = (0, _matchPath2.default)(checkPathname, pattern);

      if (matcher.match) {
        return { match: true, matcher: matcher };
      }

      if (index) {
        if (pathname === (0, _Util.resetPath)(parentPath)) {
          return { match: true, matcher: matcher };
        }
      }

      return { match: false };
    }, _this.loadComponent = function (callback) {
      if (_this.component) {
        callback(true, _this.component);
        return;
      }
      var _this$props2 = _this.props;
      var component = _this$props2.component;
      var dynamicComponent = _this$props2.loadComponent;

      if (component) {
        callback(true, component);
        return;
      }
      if (dynamicComponent) {
        dynamicComponent(function (comp) {
          callback(true, comp);
        });
        return;
      }
      callback(true, null);
    }, _this.checkFilter = function (filters, callback) {
      if (!filters) {
        callback(true);
        return;
      }
      if (!(filters instanceof Array)) {
        filters = [filters];
      }
      var tempFilters = [];
      for (var i = 0; i < filters.length; i++) {
        if (typeof filters[i] === 'function') {
          tempFilters.push(filters[i]);
        }
      }
      filters = tempFilters;

      if (filters.length === 0) {
        callback(true);
        return;
      }

      var pointer = 0; // record the index of the running filter

      var filterCallback = function filterCallback() {
        if (pointer === filters.length - 1) {
          callback(true);
        } else {
          filters[++pointer](filterCallback, _this.props, _this.context);
        }
      };

      filters[0](filterCallback, _this.props, _this.context);
    }, _this.checkMissSucceed = function () {
      _this.setToMount();
      _this.resetChildContext(true);
    }, _this.checkMiss = function () {
      var miss = _this.props.miss;

      if (!miss) {
        return;
      }
      setTimeout(function () {
        if (!_this.checkParent()) {
          return;
        }
        _this.checkMissSucceed();
      }, 0);
    }, _this.checkParent = function () {
      if (typeof _this.context.parentRouteIndex === 'undefined' || !_this.context.routes) {
        return true;
      }
      return _this.context.routes.length === _this.context.parentRouteIndex + 1;
    }, _this.hideOrShow = function () {
      var display = _this.state.mountBy === 0 ? _this.initDisplay || null : 'none';
      var dom = void 0;
      try {
        dom = _this.refs.component ? _reactDom2.default.findDOMNode(_this.refs.component) : null;
      } catch (error) {
        _Logger2.default.warning('Cannot find dom.');
        return;
      }
      if (!dom) {
        if (_react2.default.isValidElement(_this.props.children)) {
          dom = _this.props.children[0];
        }
      }

      // change display
      if (dom) {
        if (typeof _this.initDisplay === 'undefined') {
          _this.initDisplay = dom ? dom.style.display || null : null;
        }
        dom.style.display = display;
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  /** reset child context value */


  /** check 'cache' tag and link */


  /** check `cache` tag, used after route is mounted succeed */


  /** get parents' matched path */


  /** getSelfPath */


  /**
   * check path match
   * 1. direct match
   * 2. 'index' match
   */


  /** load component, contains dynamic component */


  /**
   * check filters
   * @param { Function or Array of function } filters : filters to check in order
   * @param { Function } callback(passed)
   *   @passed { Boolean } : pass result of filters
   */


  /** after check miss succeed */


  /** check 'miss' tag */


  /** check if the last matched route is it's parent */


  /** hide or show it's component after it mounted */


  return RouteUtil;
}(_react2.default.Component);

exports.default = RouteUtil;